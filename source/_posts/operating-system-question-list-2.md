---
title: 操作系统问题归档
tags: [OperatingSystem, Q&A]
mathjax: false
date: 2019-11-28 13:47:44
categories: Operating System
---

操作系统部分问答题归档整理-Part 2

<!-- more -->

## 1. 解释中断向量

- 把中断/异常与相应的处理方法对应起来
- 每种中断都会对应一个中断向量号，而这个向量号通过IDT（中断向量表）就与相应的中断处理程序对应起来了。

## 2. 解释中断类型码

把每个中断服务程序进行编号，这个号就代表一个中断服务程序，就是中断类型码。这个中断类型码是计算机用来查找中断向量用的。

## 3. 解释中断向量表

- 中断向量表是指中断向量（中断服务程序入口地址的偏移量与段基值）构成的表，一个中断向量占据4字节空间。中断向量表是8086系统内存中最低端1K字节空间，它的作用就是按照中断类型号从小到大的顺序存储对应的中断向量，总共存储256个中断向量。
- 这个地址正好和中断类型码有一种对应的关系：中断类型码*4(一个中断向量所占的空间) 就等于这个中断向量的首地址。

## 4. 实模式下中断程序地址如何得到?

根据中断类型码n，从中断向量表中取得中断处理程序地址，取得的段地址存入CS，偏移量存入IP。从而使CPU转入中断处理程序运行。

## 5. 保护模式下中断程序地址如何得到?

- 保护模式下的中断处理与实模式下的中断处理最大区别在于寻找中断处理代码入口的方式
- 在保护模式下，为每一个中断和异常定义了一个中断描述符，来说明中断和异常服务程序 的入口地址的属性
- 由中断描述符表取代实地址模式下的中断向量表

1. 查中断描述符表，以IDTR指定的中断描述符表的基地址为起始地址，用调用号N×8算出偏移量，即为N号中断门描述符的首地址，由此处取出中断门的8个字节
2. 中断描述符低地址的0和1两个字节是中断代码的偏移量A15～A0；高地址的6和7两个字节是中断代码的偏移量A31～A16；2和3两个字节是段选择符。查全局或局部描述符表根据中断门中的选择子（段选择符）和偏移量得到中断处理程序入口。

## 6. 中断向量的地址如何得到?

中断类型码*4

## 7. 实模式下如何根据中断向量的地址得到中断程序地址?

根据中断向量地址取得中断向量，低地址2个byte放偏移量，高地址2个byte放段描述符，根据描述符中基址加偏移量得到中断程序地址。

## 8. 解释中断描述符

- 低地址的0和1两个字节是中断代码的偏移量A15～A0； 高地址的6和7两个字节是中断代码的偏移量A31～A16；
- 2和3两个字节是段选择符，段选择符和偏移量用来形成中断服务子程序的入口地址； 
- 4和5两个字节称为访问权限字节，它标识该中断描述符是否有效、服务程序的特权级和描述符的类型等信息；  
  1. P（present）：表示中断描述符的有效性 
  2. DPL（descriptor privilege level）
  3. TYPE：指示中断描述符的不同类型

{% asset_img 中断描述符.png 中断描述符 %}

## 9. 保护模式下中断描述符表如何得到?

引入一个48位的全地址寄存器（即中断描述符表寄存器IDTR）存放IDT的内存地址，IDTR包含32位的基地址和16位段限，基地址定义中断描述符表IDT在存储器中的起始点，段限定义中断描述符表所占的字节个数

## 10. 保护模式下中断门如何得到?

查中断描述符表，以IDTR指定的中断描述符表的基地址为起始地址，用调用号N×8算出偏移量，即为N号中断门描述符的首地址，由此处取出中断门的8个字节

## 11. 保护模式下如何根据中断门得到中断处理程序地址?

中断描述符低地址的0和1两个字节是中断代码的偏移量A15～A0；高地址的6和7两个字节是中断代码的偏移量A31～A16；2和3两个字节是段选择符。查全局或局部描述符表根据中断门中的选择子（段选择符）和偏移量得到中断处理程序入口。

## 12. 中断的分类，举例不同类型的中断?

- 从中断源的角度分类
  1. 由计算机硬件异常或故障引起的中断，也称为**内部异常中断**。
  2. 由程序中执行了中断指令引起的中断，也称为**软中断**。由程序员通过INT或INT3指令触发，通常当做trap处理，用处：实现系统调用。
  3. 外部设备（如输入输出设备）请求引起的中断，也称为**外部中断或Ｉ/Ｏ中断**。
- 外部中断的分类
  1. 可屏蔽中断：禁止响应某个中断，保证在执行一些重要的程序中不响应中断，以免造成迟缓而引起错误。
  2. 不可屏蔽中断：重新启动、电源故障、内存出错、总线出错等影响整个系统工作的中断是不能屏蔽的。

## 13. 中断与异常的区别?

中断：由CPU以外的事件引起的中断，如I/O中断、时钟中断、控制台中断等。 

异常：来自CPU的内部事件或程序执行中的事件引起的过程，如由于CPU本身故障、程序故障和请求系统服务的指令引起的中断等。   

## 14. 实模式和保护模式下的中断处理差别

实模式下查中断向量表，保护模式下查中断描述符表

## 15. 如何识别键盘组合键 (如 `shift+a`) 是否还有其他解决方案?

《Orange's》中的实现方案：声明变量`SHIFT`来记录`shift`键的状态，当其被按下时，变量值变为`TRUE`，释放时，变量值为`FALSE`。如果当`shift`键被按下还未释放时又按下`a`键，则`if(SHIFT)`成立，于是`column`值改变，`keyrow[column]`得到的值是`shift+a`对应的`A`。

## 16. IDT 是什么，有什么作用?

中断描述符表，根据中断类型码查找中断描述符，从而调用中断服务程序。

## 17. IDT 中有几种描述符?

3种，中断门、任务门和陷阱门。

## 18. 异常的分类?

- Fault，是一种可被更正的异常，而且一旦被更正，程序可以不失连续性地继续执行。返回地址是产生fault的指令。

- Trap，一种在发生trap的指令执行之后立即被报告的异常，它也允许程序或任务不失连续性地继续执行。返回地址是产生trap的指令之后的那条指令。

- Abort，不总是报告精确异常发生位置的异常，不允许程序或任务继续执行，而是用来报告严重错误的。

## 19. 用户态和内核态的特权级分别是多少?

用户态：3，内核态：0

## 20. 中断向量表中，每个中断有几个字节? 里面的结构是什么?

每个中断向量4个字节，低地址2个byte放偏移，高地址2个byte放段描述符。中断向量表起始地址于0地址，最多256个中断向量。

## 21. 中断异常共同点 (至少两点)，不同点 (至少三点)

共同点：

1. 都是程序执行过程中的强制性转移，转移到相应的处理程序。
2. 都是软件或者硬件发生了某种情形而通知处理器的行为。

不同点：

1. 中断，是CPU所具备的功能。通常因为“硬件”而随机发生。

   异常，是“软件”运行过程中的一种开发过程中没有考虑到的程序错误。

2. 中断是CPU暂停当前工作，有计划地去处理其他的事情。中断的发生一般是可以预知的，处理的过程也是事先制定好的。处理中断时程序是正常运行的。

   异常是CPU遇到了无法响应的工作，而后进入一种非正常状态。异常的出现表明程序有缺陷。

3. 中断是异步的，异常是同步的。

   中断是来自处理器外部的I/O设备的信号的结果，它不是由指令流中某条指令执行引起的，从这个意义上讲，它是异步的，是来自指令流之外的。

   异常是执行当前指令流中的某条指令的结果，是来自指令流内部的，从这个意义上讲它们都是同步的。

4. 中断或异常的返回点

   良性的如中断和trap，只是在正常的工作流之外执行额外的操作，然后继续干没干完的活。因此处理程序完了后返回到原指令流的下一条指令，继续执行。

   恶性的如fault和abort，对于可修复fault，由于是在上一条指令执行过程中发生（是由正在执行的指令引发的）的，在修复fault之后，会重新执行该指令；至于不可修复fault或abort，则不会再返回。

5. 中断是由于当前程序无关的中断信号触发的，CPU对中断的响应是被动的，且与CPU模式无关。既可以发生在用户态，又可以发生在核心态。

   异常是由CPU控制单元产生的，大部分异常发生在用户态。

## 22. 中断或异常发生时的堆栈变化？

当从用户态堆栈切换到内核态堆栈时，先把用户态堆栈的值压入中断程序的内核态堆栈中，同时把 EFLAGS 寄存器自动压栈，然后把被中断进程的返回地址压入堆栈。如果异常产生了一个硬件错误码，则将它也保存在堆栈中。

现在 SS:ESP 的值从当前进程的TSS中获得，也就是获得当前进程的内核栈指针，因为此时中断处理程序成为当前进程的一部分，代表当前进程在运行。CS:EIP 的值就是IDT表中第$i$项门描述符的段选择符和偏移量的值，此时，CPU就跳转到了中断或异常处理程序。

中断或异常被处理完后，相应的处理程序必须产生一条`iret`指令，把控制权转交给被中断的进程，这将迫使控制单元：

1. 用保存在栈中的值装载`cs`、`eip`或`eflags`寄存器。如果一个硬件出错码曾被压入栈中，并且在`eip`内容的上面，那么，执行`iret`指令前必须先弹出这个硬件出错码。
2. 检查处理程序的`CPL`是否等于`cs`中最低两位的值（这意味着被中断的进程与处理程序运行在同一特权级）。如果是，`iret` 终止执行；否则，转入下一步。
3. 从栈中装载`ss`和`esp`寄存器，因此，返回到与旧特权级相关的栈。
4. 检查`ds`、`es`、`fs`及`gs`段寄存器的内容，如果其中一个寄存器包含的选择符是一个段描述符，并且其DPL值小于CPL，那么，清空相应的段寄存器。控制单元这么做是为了禁止用户态的程序（CPL=3）利用内核以前所用的段寄存器（DPL=0）。如果不清这些寄存器，怀有恶意的用户态程序就可能利用它们来访问内核地址空间。

{% asset_img 无特权级变换.png 无特权级变换 %}

{% asset_img 有特权级变换.png 有特权级变换 %}
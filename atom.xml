<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>近妖s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hkshu12.github.io/"/>
  <updated>2019-11-14T08:19:59.110Z</updated>
  <id>https://hkshu12.github.io/</id>
  
  <author>
    <name>Karson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统问题归档</title>
    <link href="https://hkshu12.github.io/2019/11/os-qa-list-1/"/>
    <id>https://hkshu12.github.io/2019/11/os-qa-list-1/</id>
    <published>2019-11-14T07:02:29.000Z</published>
    <updated>2019-11-14T08:19:59.110Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统部分问答题归档整理-Part 1</p><a id="more"></a><h2 id="1-什么是实模式，什么是保护模式？"><a href="#1-什么是实模式，什么是保护模式？" class="headerlink" title="1. 什么是实模式，什么是保护模式？"></a>1. 什么是实模式，什么是保护模式？</h2><ol><li><p>实模式就是用基地址加偏移量就可以直接拿到物理地址的模式。</p><ul><li>缺点：实模式非常不安全。</li></ul></li><li><p>保护模式就是不能直接拿到物理地址的模式。</p><ul><li>需要进行地址转换</li><li>从80386开始，是现代操作系统的主要模式</li></ul></li></ol><h2 id="2-什么是选择子？"><a href="#2-什么是选择子？" class="headerlink" title="2. 什么是选择子？"></a>2. 什么是选择子？</h2><ol><li>选择子共16位，放在段选择寄存器里</li><li>低2位表示请求特权级</li><li>第3位表示选择GDT方式还是LDT方式</li><li>高13位表示在描述符表中的偏移（故描述符表的项数最多是2的13次方）</li></ol><h2 id="3-什么是描述符？"><a href="#3-什么是描述符？" class="headerlink" title="3. 什么是描述符？"></a>3. 什么是描述符？</h2><p>保护模式下引入描述符来描述各种数据段，所有的描述符均为8个字节（0-7），由第5个字节说明描述符的类型。类型不同，描述符的结构也有所不同。</p><h2 id="4-什么是GDT，什么是LDT"><a href="#4-什么是GDT，什么是LDT" class="headerlink" title="4. 什么是GDT，什么是LDT?"></a>4. 什么是GDT，什么是LDT?</h2><ol><li>GDT：全局描述符表，是全局唯一的。存放一些公用的描述符、和包含各进程局部描述符表首地址的描述符。</li><li>LDT：局部描述符表，每个进程都可以有一个。存放本进程内使用的描述符。</li></ol><h2 id="5-请分别说明GDTR和LDTR的结构。"><a href="#5-请分别说明GDTR和LDTR的结构。" class="headerlink" title="5. 请分别说明GDTR和LDTR的结构。"></a>5. 请分别说明GDTR和LDTR的结构。</h2><ol><li>GDTR：48位寄存器，高32位放置GDT首地址，低16位放置GDT限长（限长决定了可寻址的大小，注意低16位放的不是选择子）</li><li>LDTR：16位寄存器，放置一个特殊的选择子，用于查找当前进程的LDT首地址。</li></ol><h2 id="6-请说明GDT直接查找物理地址的具体步骤。"><a href="#6-请说明GDT直接查找物理地址的具体步骤。" class="headerlink" title="6. 请说明GDT直接查找物理地址的具体步骤。"></a>6. 请说明GDT直接查找物理地址的具体步骤。</h2><ol><li><p>给出段选择子（放在段选择寄存器里）+偏移量</p></li><li><p>若选择了GDT方式，则从GDTR获取GDT首地址，用段选择子中的13位做偏移，拿到GDT中的描述符</p></li><li><p>如果合法且有权限，用描述符中的段首地址加上（1）中的偏移量找到物理地址。寻址结束。</p></li></ol><p><img src="/.io//GDT.png" alt="GDT"></p><h2 id="7-请说明通过LDT查找物理地址的具体步骤。"><a href="#7-请说明通过LDT查找物理地址的具体步骤。" class="headerlink" title="7. 请说明通过LDT查找物理地址的具体步骤。"></a>7. 请说明通过LDT查找物理地址的具体步骤。</h2><ol><li>给出段选择子（放在段选择寄存器中）+偏移量</li><li>若选择了LDT方式，则从GDTR获取GDT首地址，用LDTR中的偏移量做偏移，拿到GDT中的描述符1</li><li>从描述符1中获取LDT首地址，用段选择子中的13位做偏移，拿到LDT中的描述符2</li><li>如果合法且有权限，用描述符2中的段首地址加上（1）中的偏移量找到物理地址。寻址结束。</li></ol><img src="/.io//11/os-qa-list-1/LDT.png"><p><img src="/.io//LDT.png" alt="LDT"></p><h2 id="8-根目录区大小一定么？扇区号是多少？为什么？"><a href="#8-根目录区大小一定么？扇区号是多少？为什么？" class="headerlink" title="8. 根目录区大小一定么？扇区号是多少？为什么？"></a>8. 根目录区大小一定么？扇区号是多少？为什么？</h2><p>不一定。FAT12中一般从第19扇区开始。引导扇区占1扇区，2个FAT表各占9扇区，故根目录区从19扇区开始。</p><p>根目录区大小根据引导扇区中根目录区文件数的最大值<code>BPB_RootEntCnt</code>而定。</p><h2 id="9-数据区第一个簇号是多少？为什么？"><a href="#9-数据区第一个簇号是多少？为什么？" class="headerlink" title="9. 数据区第一个簇号是多少？为什么？"></a>9. 数据区第一个簇号是多少？为什么？</h2><p>2号簇。0号和1号簇被系统保留并存储特殊标识内容。0号FAT表项通常用来存放分区所在的介质类型；1号FAT表项用来存储文件系统的肮脏标志，表明文件系统被非法卸载或者磁盘表面存在错误 。</p><p>本来序号为0和1的FAT表项应该对应于簇0和簇1，但是由于这两个表项被设置成了固定值，簇0和簇1就没有存在的意义了，所以数据区就起始于簇2。</p><h2 id="10-FAT表的作用？"><a href="#10-FAT表的作用？" class="headerlink" title="10. FAT表的作用？"></a>10. FAT表的作用？</h2><p>文件分配表被划分为紧密排列的若干个表项，每个表项都与数据区中的一个簇相对应，而且表项的序号也是与簇号一一对应的。FAT项的值代表文件的下一个簇号：</p><ul><li><p>值大于或等于0xFF8，表示当前簇已经是本文件的最后一个簇</p></li><li><p>值为0xFF7，表示它是一个坏簇</p></li></ul><h2 id="11-解释静态链接的过程。"><a href="#11-解释静态链接的过程。" class="headerlink" title="11. 解释静态链接的过程。"></a>11. 解释静态链接的过程。</h2><p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处。</p><p>静态链接的主要目的就是将多个目标文件合并，并处理各目标文件用到的外部符号，对外部符号重定位（调整地址），使程序能够正常执行。静态链接一般采用两步链接的方法。</p><p><strong>第一步，空间与地址分配。</strong>扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。连接器获取所有输入目标文件的段长度后，将它们合并。</p><p><strong>第二步，符号解析与重定位。</strong>使用上一步收集到的所有信息，读取输入目标文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。</p><h2 id="12-解释动态链接的过程。"><a href="#12-解释动态链接的过程。" class="headerlink" title="12. 解释动态链接的过程。"></a>12. 解释动态链接的过程。</h2><p>使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址。  </p><p>关于静态链接和动态链接，参见：<a href="https://www.polarxiong.com/archives/静态链接与动态链接在链接过程和文件结构上的区别.html" target="_blank" rel="noopener">静态链接与动态链接在链接过程和文件结构上的区别</a></p><h2 id="13-静态链接相关PPT中为什么使用ld链接⽽不是gcc"><a href="#13-静态链接相关PPT中为什么使用ld链接⽽不是gcc" class="headerlink" title="13. 静态链接相关PPT中为什么使用ld链接⽽不是gcc"></a>13. 静态链接相关PPT中为什么使用<code>ld</code>链接⽽不是<code>gcc</code></h2><p>因为没有依赖其他库，不需要<code>gcc</code>来告诉<code>ld</code>需要加入哪些依赖并调用<code>ld</code>，可直接调用<code>ld</code>。（我猜的）</p><p>在实际自己操作的时候用<code>ld</code>链接发生了报错，用<code>objdump -rd</code>命令查看<code>test.o</code>，发现<code>gcc</code>在编译过程中在里面加了一个函数<code>__stack_chk_fail</code>，查阅发现应该是<code>gcc</code>添加用于保护数组的(?)，在用<code>ld</code>命令链接时<code>ld</code>找不到该函数而出现问题，改用<code>gcc</code>后问题消除。</p><h2 id="14-Linux下可执行文件的虚拟地址空间默认从哪里开始分配。"><a href="#14-Linux下可执行文件的虚拟地址空间默认从哪里开始分配。" class="headerlink" title="14. Linux下可执行文件的虚拟地址空间默认从哪里开始分配。"></a>14. Linux下可执行文件的虚拟地址空间默认从哪里开始分配。</h2><blockquote><p>32位Linux： 0x08048000</p><p>64位Linux： 0x00400000</p></blockquote><h2 id="15-BPB指定字段的含义"><a href="#15-BPB指定字段的含义" class="headerlink" title="15. BPB指定字段的含义"></a>15. BPB指定字段的含义</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BPB_BytsPerSec：每个扇区的字节数。</span></span><br><span class="line"><span class="keyword">BPB_SecPerClus：每一簇的扇区数。</span></span><br><span class="line"><span class="keyword">BPB_RsvdSecCnt：保留区的扇区数。（BOOT区）</span></span><br><span class="line"><span class="keyword">BPB_NumFATs：FAT表的个数。</span></span><br><span class="line"><span class="keyword">BPB_RootEntCnt：此字段指示根目录中32字节目录条目的数量。</span></span><br><span class="line"><span class="keyword">BPB_TotSec16：总扇区数，在FAT12下，当扇区总数大于0xFFFF时，该值置为0，真实值由BPB_TotSec32指定。</span></span><br><span class="line"><span class="keyword">BPB_Media：略。</span></span><br><span class="line"><span class="keyword">BPB_FATSz16：一个FAT表所占的扇区数。</span></span><br><span class="line"><span class="keyword">BPB_SecPerTrk：每个磁道的扇区数。</span></span><br><span class="line"><span class="keyword">BPB_NumHeads：略。</span></span><br><span class="line"><span class="keyword">BPB_HiddSec：隐藏扇区数。</span></span><br><span class="line"><span class="keyword">BPB_TotSec32：总扇区数。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统部分问答题归档整理-Part 1&lt;/p&gt;
    
    </summary>
    
    
      <category term="Operating System" scheme="https://hkshu12.github.io/categories/Operating-System/"/>
    
    
      <category term="OperatingSystem" scheme="https://hkshu12.github.io/tags/OperatingSystem/"/>
    
      <category term="Q&amp;A" scheme="https://hkshu12.github.io/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>大转移</title>
    <link href="https://hkshu12.github.io/2019/09/hexo-next/"/>
    <id>https://hkshu12.github.io/2019/09/hexo-next/</id>
    <published>2019-09-26T12:30:13.000Z</published>
    <updated>2019-10-12T08:58:21.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">至高无上的皇帝陛下于今日抵达自己忠实的巴黎 。</blockquote><p>我于今日把博客从WordPress迁移到了Hexo。</p><p>虽然本来也就只有一篇HelloWorld。</p><a id="more"></a><p>其实还没有完全完工，昨天晚上心心念念想着嵌入一个全局的音乐播放器组件，今天用<code>pjax</code>操作了一下，大概算是完成了一小半。<del>让人不禁想问真的有必要吗。</del></p><p>在配置好<code>pjax</code>后，NexT主题原有的<code>document.ready()</code>函数下进行的初始动画和按键监听的绑定都不能正常运作了，改天再重写吧。</p><p><del>鸽之。</del></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;至高无上的皇帝陛下于今日抵达自己忠实的巴黎 。&lt;/blockquote&gt;

&lt;p&gt;我于今日把博客从WordPress迁移到了Hexo。&lt;/p&gt;
&lt;p&gt;虽然本来也就只有一篇HelloWorld。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tech" scheme="https://hkshu12.github.io/categories/Tech/"/>
    
    
      <category term="blog" scheme="https://hkshu12.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="https://hkshu12.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>开始</title>
    <link href="https://hkshu12.github.io/2019/09/hello-world/"/>
    <id>https://hkshu12.github.io/2019/09/hello-world/</id>
    <published>2019-09-14T15:59:59.000Z</published>
    <updated>2019-09-25T14:27:15.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>七月初说要搭个博客以后，摸了2个月了。  </p><p>最初灵感大发，想要从头到尾每一行代码都自己写，搭建一个纯静态网页构成的博客，也和大佬讨论过实现细节，最后还是因为各种各样的原因不了了之了，其实还是因为懒吧。  </p><p>现在只能自我安慰有个可以用于记录自己学习和各种奇怪想法的地方就好了（但是之前的微信公众号也没更新啊），WordPress也没啥不好的。  </p><p>那么，这个博客就此起航了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World!&quot;&gt;&lt;/a&gt;Hello World!&lt;/h1&gt;&lt;p&gt;七月初说要搭个博客以后，摸了2个月了。  &lt;/p&gt;
&lt;p&gt;最初灵
      
    
    </summary>
    
    
      <category term="Life" scheme="https://hkshu12.github.io/categories/Life/"/>
    
    
      <category term="MyMind" scheme="https://hkshu12.github.io/tags/MyMind/"/>
    
  </entry>
  
</feed>
